---
title: "Statistical and Machine Learning Analysis"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(broom)
library(caret)
library(randomForest)
library(pROC)
library(gt)

theme_set(theme_minimal())
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Reusable helpers
`%||%` <- function(x, y) if (is.null(x)) y else x
fmt_pct <- function(x, digits = 1) sprintf(paste0("%.", digits, "f%%"), 100 * x)

gt_basic <- function(df, title = NULL, subtitle = NULL) {
  gt(df) |>
    tab_header(title = md(title %||% ""), subtitle = md(subtitle %||% "")) |>
    tab_options(
      table.font.names = c("Montserrat", "system-ui", "-apple-system", "Arial", "sans-serif"),
      table.width = px(760),
      heading.align = "left"
    ) |>
    fmt_missing(columns = everything(), missing_text = "—")
}

gt_compact <- function(df, title = NULL, subtitle = NULL) {
  gt_basic(df, title, subtitle) |>
    opt_row_striping() |>
    cols_align(align = "left", columns = everything()) |>
    tab_style(
      style = cell_borders(sides = "all", color = "#e6e6e6", weight = px(1)),
      locations = cells_body()
    )
}

# Pokémon type palette (consistent with EDA)
type_cols <- c(
  "Bug"      = "#A6B91A", "Dark"     = "#705746", "Dragon"   = "#6F35FC",
  "Electric" = "#F7D02C", "Fairy"    = "#D685AD", "Fighting" = "#C22E28",
  "Fire"     = "#EE8130", "Flying"   = "#A98FF3", "Ghost"    = "#735797",
  "Grass"    = "#7AC74C", "Ground"   = "#E2BF65", "Ice"      = "#96D9D6",
  "Normal"   = "#A8A77A", "Poison"   = "#A33EA1", "Psychic"  = "#F95587",
  "Rock"     = "#B6A136", "Steel"    = "#B7B7CE", "Water"    = "#6390F0"
)
```

```{r data}
poke <- readr::read_csv("Data/pokemon_clean.csv", show_col_types = FALSE) |>
  mutate(
    type1        = as.factor(stringr::str_to_title(type1)),
    generation   = as.factor(generation),
    is_legendary = as.logical(is_legendary)
  )
```

## Do primary types differ in total base stats?

#### Hypotheses:

We examined whether mean total base stats differ across primary Pokémon types.

- H₀: Mean base_total is equal across all primary types.
- H₁: At least one primary type has a different mean base_total.

#### Measures

- Grouping: type1 (primary type).
- Outcome: base_total (sum of HP, Attack, Defense, Sp. Attack, Sp. Defense, Speed). We fit a one-way ANOVA and followed with Tukey post-hoc tests to identify which pairs of types differ.

```{r anova}
anova_fit <- aov(base_total ~ type1, data = poke)
anova_tidy <- broom::tidy(anova_fit)

# Clear, human-friendly ANOVA table
ss_total <- sum(anova_tidy$sumsq, na.rm = TRUE)
anova_tbl <- anova_tidy |>
  transmute(
    Term          = case_when(term == "type1" ~ "Primary Type (type1)",
                              term == "Residuals" ~ "Residuals",
                              TRUE ~ term),
    DF            = df,
    `Sum Sq`      = round(sumsq, 2),
    `Mean Sq`     = round(meansq, 2),
    `F Statistic` = round(statistic %||% NA_real_, 3),
    `Pr(>F)`      = scales::pvalue(p.value %||% NA_real_),
    `Eta-squared` = ifelse(term == "type1", round(sumsq / ss_total, 3), NA_real_)
  )

gt_compact(anova_tbl, title = "ANOVA: Base Total ~ Primary Type",
           subtitle = "Effect size shown as Eta-squared for type1")
```

```{r anova-boxplot}
# Boxplot by type with palette
ggplot(poke, aes(type1, base_total, fill = type1)) +
  geom_boxplot(outlier.alpha = 0.25, width = 0.7) +
  scale_fill_manual(values = type_cols, guide = "none") +
  labs(title = "Base Total by Primary Type",
       x = "Primary Type", y = "Total Base Stats") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r tukey-results, include=FALSE}
# Tukey post-hoc results (kept for plotting and a brief summary)
tuk <- TukeyHSD(anova_fit)
tuk_raw <- broom::tidy(tuk)

tuk_tidy <- tuk_raw |>
  mutate(
    Type_A      = sub("-.*$", "", contrast),
    Type_B      = sub(".*-", "", contrast),
    `Mean Diff` = estimate,
    `CI Low`    = conf.low,
    `CI High`   = conf.high,
    Significant = adj.p.value < 0.05
  )

sig_count <- sum(tuk_tidy$Significant, na.rm = TRUE)
total_pairs <- nrow(tuk_tidy)
```

```{r tukey-plot-sig}
# Visualize ONLY significant Tukey differences with type colors (by Type B)
tukey_sig_df <- tuk_tidy |>
  filter(Significant) |>
  mutate(
    Pair     = paste0(Type_B, " - ", Type_A),
    `Type B` = Type_B
  ) |>
  arrange(`Mean Diff`)

ggplot(tukey_sig_df,
       aes(y = reorder(Pair, `Mean Diff`), x = `Mean Diff`, color = `Type B`)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray40") +
  geom_errorbarh(aes(xmin = `CI Low`, xmax = `CI High`), height = 0.28, size = 1.0) +
  geom_point(size = 2.6) +
  scale_color_manual(values = type_cols, guide = guide_legend(title = "Type B")) +
  labs(
    title = "Significant Tukey Post-hoc Differences (adj p < 0.05)",
    subtitle = paste0(sig_count, " significant pairs out of ", total_pairs, " total comparisons"),
    x = "Mean Difference in Total Base Stats (B - A)",
    y = "Type Pair (B - A)"
  ) +
  theme(legend.position = "top")
```

#### Results 

The ANOVA indicated significant differences in mean total base stats across primary types. The Tukey summary plot highlights the specific pairs with significant differences and their effect directions. Together, these results show that type is associated with systematic variation in base_total.

#### Interpretation 

While distributions overlap across types, several pairwise differences are statistically meaningful, consistent with design patterns where certain types (e.g., Dragon, Steel) tend to have stronger stat profiles. This supports using type as an informative factor in downstream modeling and interpretation.

## Are dual-type Pokémon stronger than single-type Pokémon?

#### Hypotheses

We examined whether dual-type Pokémon have a statistical advantage over single-type Pokémon in terms of overall combat strength. Specifically, we tested whether mean total base stats differ between Single-type and Dual-type Pokémon.

- H₀: There is no difference in mean base_total between Single-type and Dual-type Pokémon.
- H₁: There is a difference in mean base_total between Single-type and Dual-type Pokémon.

#### Measures

- Grouping: dual_type is “Single” when type2 == "None", otherwise “Dual”.
- Outcome: base_total is the sum of HP, Attack, Defense, Sp. Attack, Sp. Defense, and Speed.

We conducted a Welch two-sample t-test (allowing unequal variances) and visualized the distributions using violin and boxplots.

```{r dualtype-setup, include=FALSE}
library(broom)
library(gt)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Helper to render compact gt tables
gt_compact <- function(df, title = NULL, subtitle = NULL) {
  gt::gt(df) |>
    gt::tab_header(title = gt::md(title %||% ""), subtitle = gt::md(subtitle %||% "")) |>
    gt::opt_row_striping() |>
    gt::cols_align(align = "left", columns = gt::everything()) |>
    gt::tab_options(
      table.font.names = c("Montserrat", "system-ui", "-apple-system", "Arial", "sans-serif"),
      table.width = gt::px(760),
      heading.align = "left"
    ) |>
    gt::fmt_missing(columns = gt::everything(), missing_text = "—")
}
`%||%` <- function(x, y) if (is.null(x)) y else x
```

```{r dualtype-data}
# Use the cleaned dataset already loaded earlier in the page as `poke`
dual_df <- poke |>
  mutate(
    type2 = stringr::str_to_title(type2),
    dual_type = if_else(type2 == "None", "Single", "Dual")
  )
```

```{r dualtype-test}
tt_dual <- t.test(base_total ~ dual_type, data = dual_df, var.equal = FALSE)
tt_dual_tidy <- broom::tidy(tt_dual) |>
  transmute(
    `Mean Diff (Dual - Single)` = round(estimate, 2),
    `95% CI Low`  = round(conf.low, 2),
    `95% CI High` = round(conf.high, 2),
    `p-value`     = scales::pvalue(p.value)
  )

group_summary <- dual_df |>
  group_by(dual_type) |>
  summarise(
    N          = n(),
    `Mean Total` = round(mean(base_total, na.rm = TRUE), 1),
    `SD Total`   = round(sd(base_total, na.rm = TRUE), 1),
    .groups = "drop"
  ) |>
  arrange(desc(dual_type))

gt_compact(group_summary, title = "Group Summary: Single vs Dual-type", subtitle = "Total Base Stats by typing (means and SDs)")
gt_compact(tt_dual_tidy, title = "Two-sample t-test", subtitle = "Outcome: Total Base Stats; Grouping: Dual vs Single")
```

```{r dualtype-viz}
ggplot(dual_df, aes(x = dual_type, y = base_total, fill = dual_type)) +
  geom_violin(trim = FALSE, alpha = 0.55) +
  geom_boxplot(width = 0.20, alpha = 0.55, outlier.alpha = 0.35) +
  scale_fill_manual(values = c("Single" = "#6390F0", "Dual" = "#EE8130"), guide = "none") +
  labs(
    x = "Typing",
    y = "Total Base Stats",
    title = "Single-type vs Dual-type Pokémon: Total Stats Comparison"
  )
```

#### Results

On average, Dual-type Pokémon have higher total base stats than Single-type Pokémon. The mean difference, confidence interval, and p-value are shown in the t-test table above. Because the confidence interval excludes zero and the p-value is well below 0.05 in our dataset, we reject H₀ and conclude Dual-type Pokémon tend to have higher total base stats than Single-type Pokémon.

#### Interpretation

The violin+boxplot shows the Dual-type distribution shifted upward relative to Single-type, indicating a higher median and denser cluster among higher stats. There is overlap between groups, so typing alone doesn’t determine strength, but the average advantage of Dual-type is consistent. Generation design could play a role (e.g., later generations may emphasize dual typing), and battle mechanics suggest dual typing provides resistance and flexibility—potentially reflected in higher overall base stats.

## Are legendary Pokémon stronger?

#### Hypotheses:

We tested whether legendary Pokémon have higher mean total base stats than non-legendary Pokémon.

- H₀: Mean base_total is equal between legendary and non-legendary Pokémon.
- H₁: Mean base_total differs between legendary and non-legendary Pokémon.

#### Measures

- Grouping: is_legendary (TRUE/FALSE).
- Outcome: base_total (sum of six base stats). We conducted a two-sample t-test and visualized distributions with density overlays.

```{r ttest}
tt <- t.test(base_total ~ is_legendary, data = poke)
tt_tidy <- broom::tidy(tt)

# Friendly t-test summary
means <- poke |>
  group_by(is_legendary) |>
  summarise(
    `Mean Total` = round(mean(base_total, na.rm = TRUE), 2),
    N            = n(),
    .groups = "drop"
  ) |>
  mutate(Group = ifelse(is_legendary, "Legendary", "Non-legendary")) |>
  select(Group, N, `Mean Total`)

tt_tbl <- tibble::tibble(
  `Mean Difference (Legendary - Non)` = round(tt_tidy$estimate, 2),
  `95% CI Low`  = round(tt_tidy$conf.low, 2),
  `95% CI High` = round(tt_tidy$conf.high, 2),
  `p-value`     = scales::pvalue(tt_tidy$p.value)
)

gt_compact(means, title = "Group Means: Total Base Stats") |>
  tab_source_note(md("Groups defined by `is_legendary`."))
gt_compact(tt_tbl, title = "Two-sample t-test",
           subtitle = "Outcome: Total Base Stats; Grouping: Legendary vs Non-legendary")
```

```{r ttest-viz}
ggplot(poke, aes(base_total, fill = is_legendary)) +
  geom_density(alpha = 0.35) +
  scale_fill_manual(values = c(`FALSE` = "#6390F0", `TRUE` = "#EE8130"),
                    labels = c("Non-legendary", "Legendary"), name = NULL) +
  labs(title = "Distribution of Total Base Stats by Legendary Status",
       x = "Total Base Stats", y = "Density") +
  theme(legend.position = "top")
```

#### Results 

Legendary Pokémon exhibit substantially higher mean base_total compared to non-legendary. The confidence interval excludes zero and the p-value is far below 0.05, supporting rejection of H₀.

#### Interpretation 

The density plot shows the legendary distribution shifted toward higher totals, consistent with franchise design choices that make legendaries stronger on average. This motivates logistic regression using base_total and other predictors to model legendary status.

## Are stronger Pokémon harder to catch?

#### Hypotheses

- H₀: No linear relationship between capture_rate and base_total among non-legendary Pokémon after adjusting for covariates.
- H₁: A significant negative relationship exists: harder-to-catch Pokémon (lower capture_rate) have higher base_total, controlling for covariates.

#### Measures and covariates

- Exposure: capture_rate (numeric; higher = easier to catch).
- Outcome: base_total (sum of HP, Attack, Defense, Sp. Attack, Sp. Defense, Speed).
- Covariates: Height (m), Weight (kg), Percentage Male, Generation group (Early vs Modern).

```{r capture-rate-setup, include=FALSE}
library(broom)
library(gt)
library(tidyverse)

# compact gt helper (reuses your existing style)
gt_compact <- function(df, title = NULL, subtitle = NULL) {
  gt::gt(df) |>
    gt::tab_header(title = gt::md(title %||% ""), subtitle = gt::md(subtitle %||% "")) |>
    gt::opt_row_striping() |>
    gt::cols_align(align = "left", columns = gt::everything()) |>
    gt::tab_options(
      table.font.names = c("Montserrat", "system-ui", "-apple-system", "Arial", "sans-serif"),
      table.width = gt::px(760),
      heading.align = "left"
    ) |>
    gt::fmt_missing(columns = gt::everything(), missing_text = "—")
}
`%||%` <- function(x, y) if (is.null(x)) y else x
```

```{r capture-rate-data}
# Build analysis sample and covariates
capture_stats <- poke |>
  filter(!is_legendary) |>
  mutate(
    capture_rate    = suppressWarnings(as.numeric(capture_rate)),
    percentage_male = suppressWarnings(as.numeric(percentage_male)),
    generation_grp  = case_when(
      generation %in% c("1","2","3") ~ "Early",
      generation %in% c("4","5","6","7") ~ "Modern",
      TRUE ~ NA_character_
    )
  ) |>
  mutate(generation_grp = factor(generation_grp, levels = c("Early", "Modern"))) |>
  filter(if_all(c(capture_rate, base_total, height_m, weight_kg, percentage_male, generation_grp), ~ !is.na(.x)))
```

```{r capture-rate-model}
# Linear regression: total stats ~ capture rate + size + sex + generation group
lm_fit <- lm(
  base_total ~ capture_rate + height_m + weight_kg + percentage_male + generation_grp,
  data = capture_stats
)

lm_tidy <- broom::tidy(lm_fit, conf.int = TRUE) |>
  mutate(
    term = recode(term,
      "(Intercept)"          = "Intercept",
      "capture_rate"         = "Capture Rate (higher = easier)",
      "height_m"             = "Height (m)",
      "weight_kg"            = "Weight (kg)",
      "percentage_male"      = "Percentage Male",
      "generation_grpModern" = "Generation: Modern (vs Early)"
    )
  ) |>
  transmute(
    Predictor = term,
    Estimate  = round(estimate, 2),
    `95% CI Low`  = round(conf.low, 2),
    `95% CI High` = round(conf.high, 2),
    `p-value`     = scales::pvalue(p.value)
  )

gt_compact(lm_tidy,
  title = "Regression: Capture Rate Predicting Total Base Stats (non-legendary)",
  subtitle = "Model adjusts for Height, Weight, Percentage Male, and Generation group"
)
```

```{r capture-rate-plot}
# Visualization: relationship with fitted line (partial, not residualized)
ggplot(capture_stats, aes(capture_rate, base_total)) +
  geom_point(alpha = 0.45, color = "#1976d2") +
  geom_smooth(method = "lm", se = TRUE, color = "#c22e28") +
  labs(
    title = "Capture Rate vs Total Base Stats (non-legendary)",
    subtitle = "Higher capture_rate means easier to catch",
    x = "Capture Rate",
    y = "Total Base Stats"
  )
```

#### Interpretation

The regression table shows a significant negative coefficient for Capture Rate, indicating that, among non-legendary Pokémon, species that are harder to catch tend to have higher total base stats, even after adjusting for physical size, sex distribution, and generation group. The plot illustrates the overall downward trend. This supports rejecting H₀ in favor of H₁.

## Can we predict legendary status from stats, type and generation?

#### Hypotheses:

We modeled whether a Pokémon is legendary based on total stats, primary type, and generation.

- H₀: base_total, type1, and generation are not associated with legendary status.
- H₁: At least one of base_total, type1, or generation is associated with legendary status.

#### Measures

- Outcome: is_legendary (binary; TRUE/FALSE).
- Predictors: base_total (numeric), type1 (categorical), generation (categorical). We fit a logistic regression and reported exponentiated coefficients (odds ratios) with confidence intervals. Model discrimination was evaluated via ROC curve and AUC, and calibration via predicted vs observed rates in deciles.

```{r logistic}
glm_fit <- glm(
  is_legendary ~ base_total + type1 + generation,
  data = poke,
  family = binomial()
)

glm_tidy <- broom::tidy(glm_fit, exponentiate = TRUE, conf.int = TRUE) |>
  transmute(
    Term        = case_when(
      term == "(Intercept)" ~ "Intercept",
      grepl("^type1", term) ~ gsub("^type1", "Type1:", term),
      grepl("^generation", term) ~ gsub("^generation", "Gen:", term),
      TRUE ~ term
    ),
    `Odds Ratio` = round(estimate, 3),
    `CI Low`     = round(conf.low, 3),
    `CI High`    = round(conf.high, 3),
    `p-value`    = scales::pvalue(p.value)
  )

gt_compact(glm_tidy, title = "Logistic Regression (Odds Ratios)",
           subtitle = "Outcome: Legendary status; predictors include total, type, generation")
```

```{r logistic-roc}
pred_prob <- predict(glm_fit, type = "response")
roc_obj   <- pROC::roc(response = poke$is_legendary, predictor = pred_prob)
auc_val   <- as.numeric(pROC::auc(roc_obj))

# ROC summary table + plot
roc_tbl <- tibble::tibble(`AUC` = round(auc_val, 3))
gt_compact(roc_tbl, title = "ROC AUC")

plot(roc_obj, col = "#1976d2", lwd = 2, main = paste0("ROC Curve (AUC = ", round(auc_val, 3), ")"))
abline(0, 1, lty = 2, col = "gray40")
```

```{r logistic-calibration}
# Calibration: predicted vs empirical rate (deciles)
calib_df <- tibble(
  pred = pred_prob,
  y    = poke$is_legendary
) |>
  mutate(bin = cut(pred, breaks = seq(0, 1, by = 0.1), include.lowest = TRUE)) |>
  group_by(bin) |>
  summarise(
    `Mean Pred` = mean(pred),
    `Empirical Rate` = mean(y),
    N = n(),
    .groups = "drop"
  )

gt_compact(calib_df, title = "Calibration bins",
           subtitle = "Predicted probability vs empirical legendary rate (deciles)")

ggplot(calib_df, aes(`Mean Pred`, `Empirical Rate`)) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray40") +
  geom_point(size = 2, color = "#d32f2f") +
  geom_smooth(method = "lm", se = FALSE, color = "#1976d2", linetype = "dotted") +
  labs(title = "Calibration: Predicted vs Empirical Legendary Rate",
       x = "Mean Predicted Probability (bin)", y = "Empirical Legendary Rate")
```

#### Results 

The odds ratios indicate that base_total is a strong positive predictor of legendary status, with higher totals substantially increasing the odds that a Pokémon is legendary. Type and generation effects are smaller and more nuanced, with some categories contributing modest shifts. The ROC AUC demonstrates good discrimination between legendary and non‑legendary classes, and the calibration plot shows predicted probabilities align reasonably with empirical rates.

#### Interpretation 

Total base stats are the dominant signal for legendary designation, reflecting the franchise’s design that legendaries are stronger on average. Type and generation provide secondary context that can refine predictions but play a smaller role than total stats. Overall, the model effectively distinguishes legendary from non‑legendary Pokémon and is well‑calibrated for interpretation.

## Can we predict primary type from base stats?

#### Hypotheses:

We assessed whether base stats alone can predict a Pokémon’s primary type better than chance.

- H₀: Base stats provide no predictive power beyond chance for identifying primary type.
- H₁: Base stats contain predictive signal for primary type classification.

#### Measures

- Outcome: type1 (categorical).
- Predictors: hp, attack, defense, sp_attack, sp_defense, speed (numeric). We trained a Random Forest with an 80/20 train‑test split, reported test accuracy against a naive baseline (1 / number of types), inspected variable importance (Mean Decrease Gini), and visualized the confusion matrix to understand per‑type performance.

```{r rf}
set.seed(123)
poke_type <- poke |>
  select(type1, hp, attack, defense, sp_attack, sp_defense, speed) |>
  mutate(type1 = factor(type1))

idx   <- createDataPartition(poke_type$type1, p = 0.8, list = FALSE)
train <- poke_type[idx, ]
test  <- poke_type[-idx, ]

rf_fit <- randomForest(type1 ~ ., data = train, ntree = 500, importance = TRUE)
pred   <- predict(rf_fit, newdata = test)

acc      <- mean(pred == test$type1)
baseline <- 1 / length(levels(train$type1))

rf_summary <- tibble::tibble(
  Metric  = c("Accuracy", "Naive baseline (1 / #types)", "Improvement (pts)"),
  Value   = c(fmt_pct(acc, 2), fmt_pct(baseline, 2), sprintf("%.2f pts", 100 * (acc - baseline)))
)

gt_compact(rf_summary, title = "Random Forest Performance Summary")
```

```{r rf-importance}
imp <- importance(rf_fit)
imp_tbl <- tibble::tibble(
  Stat = rownames(imp),
  `Mean Decrease Gini` = round(imp[, "MeanDecreaseGini"], 2)
) |>
  arrange(desc(`Mean Decrease Gini`))

gt_compact(imp_tbl, title = "Variable Importance (Mean Decrease Gini)")

ggplot(imp_tbl, aes(x = reorder(Stat, `Mean Decrease Gini`), y = `Mean Decrease Gini`)) +
  geom_col(fill = "#6F35FC") +
  coord_flip() +
  labs(title = "Random Forest: Variable Importance",
       x = "Stat", y = "Mean Decrease Gini")
```

```{r rf-confusion}
cm_table <- table(Truth = test$type1, Pred = pred)
cm_df    <- as.data.frame(cm_table)

# Confusion matrix (heatmap) with counts
ggplot(cm_df, aes(Pred, Truth, fill = Freq)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "#e0ecf4", high = "#0868ac") +
  geom_text(aes(label = Freq), color = "black", size = 3) +
  labs(title = "Random Forest Confusion Matrix (Test Set)", x = "Predicted Type", y = "True Type") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Results 

Test accuracy exceeds the naive baseline, indicating that base stats contain meaningful type‑specific patterns. Variable importance highlights offensive attributes—especially Special Attack, Attack, and Speed—as the most influential predictors, with defensive stats contributing less. The confusion matrix shows strong performance for some types and confusions among types with overlapping stat profiles.

#### Interpretation 

Offensive profiles and speed tiers are more distinctive across types than defensive stats, consistent with battle mechanics where types often specialize in offense. Misclassifications tend to occur among types with similar stat distributions, explaining moderate overall accuracy despite robust signals for certain types. These findings support the idea that base stats encode type identity to a useful, but not perfect, degree.